'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const path = require('path');
const debug = require('debug')('email-templates');
const fs = require('fs-extra');
const htmlToText = require('html-to-text');
const I18N = require('@ladjs/i18n');
const autoBind = require('auto-bind');
const nodemailer = require('nodemailer');
const consolidate = require('consolidate');
const previewEmail = require('preview-email');
const _ = require('lodash');
const Promise = require('bluebird');

const getPaths = require('get-paths');
const juiceResources = require('juice-resources-promise');

const env = process.env.NODE_ENV || 'development';

class Email {
  constructor(config = {}) {
    debug('config passed %O', config);

    // 2.x backwards compatible support
    if (config.juiceOptions) {
      config.juiceResources = config.juiceOptions;
      delete config.juiceOptions;
    }
    if (config.disableJuice) {
      config.juice = false;
      delete config.disableJuice;
    }
    if (config.render) {
      config.customRender = true;
    }

    this.config = _.merge({
      views: {
        // directory where email templates reside
        root: path.resolve('emails'),
        options: {
          // default file extension for template
          extension: 'pug',
          map: {
            hbs: 'handlebars',
            njk: 'nunjucks'
          },
          engineSource: consolidate
        },
        // locals to pass to templates for rendering
        locals: {
          // pretty is automatically set to `false` for subject/text
          pretty: true
        }
      },
      // <https://nodemailer.com/message/>
      message: {},
      send: !['development', 'test'].includes(env),
      preview: env === 'development',
      // <https://github.com/ladjs/i18n>
      // set to an object to configure and enable it
      i18n: false,
      // pass a custom render function if necessary
      render: this.render.bind(this),
      customRender: false,
      // force text-only rendering of template (disregards template folder)
      textOnly: false,
      // <https://github.com/werk85/node-html-to-text>
      htmlToText: {
        ignoreImage: true
      },
      subjectPrefix: false,
      // <https://github.com/Automattic/juice>
      juice: true,
      juiceResources: {
        preserveImportant: true,
        webResources: {
          relativeTo: path.resolve('build')
        }
      },
      // pass a transport configuration object or a transport instance
      // (e.g. an instance is created via `nodemailer.createTransport`)
      // <https://nodemailer.com/transports/>
      transport: {}
    }, config);

    // override existing method
    this.render = this.config.render;

    if (!_.isFunction(this.config.transport.sendMail)) this.config.transport = nodemailer.createTransport(this.config.transport);

    debug('transformed config %O', this.config);

    autoBind(this);
  }

  // shorthand use of `juiceResources` with the config
  // (mainly for custom renders like from a database)
  juiceResources(html) {
    return juiceResources(html, this.config.juiceResources);
  }

  // a simple helper function that gets the actual file path for the template
  getTemplatePath(view) {
    var _this = this;

    return new Promise((() => {
      var _ref = _asyncToGenerator(function* (resolve, reject) {
        try {
          const paths = yield getPaths(_this.config.views.root, view, _this.config.views.options.extension);
          const filePath = path.resolve(_this.config.views.root, paths.rel);
          resolve({ filePath, paths });
        } catch (err) {
          reject(err);
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    })());
  }

  // returns true or false if a template exists
  // (uses same look-up approach as `render` function)
  templateExists(view) {
    var _this2 = this;

    return new Promise((() => {
      var _ref2 = _asyncToGenerator(function* (resolve) {
        try {
          var _ref3 = yield _this2.getTemplatePath(view);

          const filePath = _ref3.filePath;

          const stats = yield fs.stat(filePath);
          if (!stats.isFile()) throw new Error(`${filePath} was not a file`);
          resolve(true);
        } catch (err) {
          debug('templateExists', err);
          resolve(false);
        }
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    })());
  }

  // promise version of consolidate's render
  // inspired by koa-views and re-uses the same config
  // <https://github.com/queckezz/koa-views>
  render(view, locals = {}) {
    var _this3 = this;

    return new Promise((() => {
      var _ref4 = _asyncToGenerator(function* (resolve, reject) {
        try {
          var _config$views$options = _this3.config.views.options;
          const map = _config$views$options.map,
                engineSource = _config$views$options.engineSource;

          var _ref5 = yield _this3.getTemplatePath(view);

          const filePath = _ref5.filePath,
                paths = _ref5.paths;

          if (paths.ext === 'html' && !map) {
            const res = yield fs.readFile(filePath, 'utf8');
            resolve(res);
          } else {
            const engineName = map && map[paths.ext] ? map[paths.ext] : paths.ext;
            const renderFn = engineSource[engineName];
            if (!engineName || !renderFn) return reject(new Error(`Engine not found for the ".${paths.ext}" file extension`));

            if (_.isObject(_this3.config.i18n)) {
              const i18n = new I18N(Object.assign({}, _this3.config.i18n, {
                register: locals
              }));

              // support `locals.user.last_locale`
              // (e.g. for <https://lad.js.org>)
              if (_.isObject(locals.user) && _.isString(locals.user.last_locale)) locals.locale = locals.user.last_locale;

              if (_.isString(locals.locale)) i18n.setLocale(locals.locale);
            }

            // TODO: convert this to a promise based version
            renderFn(filePath, locals, function (err, res) {
              if (err) return reject(err);
              // transform the html with juice using remote paths
              // google now supports media queries
              // https://developers.google.com/gmail/design/reference/supported_css
              if (!_this3.config.juice) return resolve(res);
              _this3.juiceResources(res).then(resolve).catch(reject);
            });
          }
        } catch (err) {
          reject(err);
        }
      });

      return function (_x4, _x5) {
        return _ref4.apply(this, arguments);
      };
    })());
  }

  renderAll(template, locals = {}, message = {}) {
    var _this4 = this;

    return new Promise((() => {
      var _ref6 = _asyncToGenerator(function* (resolve, reject) {
        try {
          let subjectTemplateExists = _this4.config.customRender;
          let htmlTemplateExists = _this4.config.customRender;
          let textTemplateExists = _this4.config.customRender;

          const promises = [_this4.templateExists(`${template}/subject`), _this4.templateExists(`${template}/html`), _this4.templateExists(`${template}/text`)];

          if (template && !_this4.config.customRender) {
            ;

            var _ref7 = yield Promise.all(promises);

            var _ref8 = _slicedToArray(_ref7, 3);

            subjectTemplateExists = _ref8[0];
            htmlTemplateExists = _ref8[1];
            textTemplateExists = _ref8[2];
          }if (!message.subject && subjectTemplateExists) {
            message.subject = yield _this4.render(`${template}/subject`, Object.assign({}, locals, { pretty: false }));
            message.subject = message.subject.trim();
          }

          if (message.subject && _this4.config.subjectPrefix) message.subject = _this4.config.subjectPrefix + message.subject;

          if (!message.html && htmlTemplateExists) message.html = yield _this4.render(`${template}/html`, locals);

          if (!message.text && textTemplateExists) message.text = yield _this4.render(`${template}/text`, Object.assign({}, locals, { pretty: false }));

          if (_this4.config.htmlToText && message.html && !message.text)
            // we'd use nodemailer-html-to-text plugin
            // but we really don't need to support cid
            // <https://github.com/andris9/nodemailer-html-to-text>
            message.text = htmlToText.fromString(message.html, _this4.config.htmlToText);

          // if we only want a text-based version of the email
          if (_this4.config.textOnly) delete message.html;

          resolve(message);
        } catch (err) {
          reject(err);
        }
      });

      return function (_x6, _x7) {
        return _ref6.apply(this, arguments);
      };
    })());
  }

  send(options = {}) {
    var _this5 = this;

    options = Object.assign({
      template: '',
      message: {},
      locals: {}
    }, options);

    var _options = options;
    let template = _options.template,
        message = _options.message,
        locals = _options.locals;


    const attachments = message.attachments || this.config.message.attachments || [];

    message = _.defaultsDeep({}, _.omit(this.config.message, 'attachments'), _.omit(message, 'attachments'));
    locals = _.defaultsDeep({}, this.config.views.locals, locals);

    if (attachments) message.attachments = attachments;

    debug('template %s', template);
    debug('message %O', message);
    debug('locals (keys only): %O', Object.keys(locals));

    return new Promise((() => {
      var _ref9 = _asyncToGenerator(function* (resolve, reject) {
        try {
          // get all available templates
          const obj = yield _this5.renderAll(template, locals, message);

          // assign the object variables over to the message
          Object.assign(message, obj);

          if (_this5.config.preview) {
            debug('using `preview-email` to preview email');
            yield previewEmail(message);
          }

          if (!_this5.config.send) {
            debug('send disabled so we are ensuring JSONTransport');
            // <https://github.com/nodemailer/nodemailer/issues/798>
            // if (this.config.transport.name !== 'JSONTransport')
            _this5.config.transport = nodemailer.createTransport({
              jsonTransport: true
            });
          }

          const res = yield _this5.config.transport.sendMail(message);
          debug('message sent');
          resolve(res);
        } catch (err) {
          reject(err);
        }
      });

      return function (_x8, _x9) {
        return _ref9.apply(this, arguments);
      };
    })());
  }
}

module.exports = Email;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsImRlYnVnIiwiZnMiLCJodG1sVG9UZXh0IiwiSTE4TiIsImF1dG9CaW5kIiwibm9kZW1haWxlciIsImNvbnNvbGlkYXRlIiwicHJldmlld0VtYWlsIiwiXyIsIlByb21pc2UiLCJnZXRQYXRocyIsImp1aWNlUmVzb3VyY2VzIiwiZW52IiwicHJvY2VzcyIsIk5PREVfRU5WIiwiRW1haWwiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImp1aWNlT3B0aW9ucyIsImRpc2FibGVKdWljZSIsImp1aWNlIiwicmVuZGVyIiwiY3VzdG9tUmVuZGVyIiwibWVyZ2UiLCJ2aWV3cyIsInJvb3QiLCJyZXNvbHZlIiwib3B0aW9ucyIsImV4dGVuc2lvbiIsIm1hcCIsImhicyIsIm5qayIsImVuZ2luZVNvdXJjZSIsImxvY2FscyIsInByZXR0eSIsIm1lc3NhZ2UiLCJzZW5kIiwiaW5jbHVkZXMiLCJwcmV2aWV3IiwiaTE4biIsImJpbmQiLCJ0ZXh0T25seSIsImlnbm9yZUltYWdlIiwic3ViamVjdFByZWZpeCIsInByZXNlcnZlSW1wb3J0YW50Iiwid2ViUmVzb3VyY2VzIiwicmVsYXRpdmVUbyIsInRyYW5zcG9ydCIsImlzRnVuY3Rpb24iLCJzZW5kTWFpbCIsImNyZWF0ZVRyYW5zcG9ydCIsImh0bWwiLCJnZXRUZW1wbGF0ZVBhdGgiLCJ2aWV3IiwicmVqZWN0IiwicGF0aHMiLCJmaWxlUGF0aCIsInJlbCIsImVyciIsInRlbXBsYXRlRXhpc3RzIiwic3RhdHMiLCJzdGF0IiwiaXNGaWxlIiwiRXJyb3IiLCJleHQiLCJyZXMiLCJyZWFkRmlsZSIsImVuZ2luZU5hbWUiLCJyZW5kZXJGbiIsImlzT2JqZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwicmVnaXN0ZXIiLCJ1c2VyIiwiaXNTdHJpbmciLCJsYXN0X2xvY2FsZSIsImxvY2FsZSIsInNldExvY2FsZSIsInRoZW4iLCJjYXRjaCIsInJlbmRlckFsbCIsInRlbXBsYXRlIiwic3ViamVjdFRlbXBsYXRlRXhpc3RzIiwiaHRtbFRlbXBsYXRlRXhpc3RzIiwidGV4dFRlbXBsYXRlRXhpc3RzIiwicHJvbWlzZXMiLCJhbGwiLCJzdWJqZWN0IiwidHJpbSIsInRleHQiLCJmcm9tU3RyaW5nIiwiYXR0YWNobWVudHMiLCJkZWZhdWx0c0RlZXAiLCJvbWl0Iiwia2V5cyIsIm9iaiIsImpzb25UcmFuc3BvcnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFNQSxPQUFPQyxRQUFRLE1BQVIsQ0FBYjtBQUNBLE1BQU1DLFFBQVFELFFBQVEsT0FBUixFQUFpQixpQkFBakIsQ0FBZDtBQUNBLE1BQU1FLEtBQUtGLFFBQVEsVUFBUixDQUFYO0FBQ0EsTUFBTUcsYUFBYUgsUUFBUSxjQUFSLENBQW5CO0FBQ0EsTUFBTUksT0FBT0osUUFBUSxhQUFSLENBQWI7QUFDQSxNQUFNSyxXQUFXTCxRQUFRLFdBQVIsQ0FBakI7QUFDQSxNQUFNTSxhQUFhTixRQUFRLFlBQVIsQ0FBbkI7QUFDQSxNQUFNTyxjQUFjUCxRQUFRLGFBQVIsQ0FBcEI7QUFDQSxNQUFNUSxlQUFlUixRQUFRLGVBQVIsQ0FBckI7QUFDQSxNQUFNUyxJQUFJVCxRQUFRLFFBQVIsQ0FBVjtBQUNBLE1BQU1VLFVBQVVWLFFBQVEsVUFBUixDQUFoQjs7QUFFQSxNQUFNVyxXQUFXWCxRQUFRLFdBQVIsQ0FBakI7QUFDQSxNQUFNWSxpQkFBaUJaLFFBQVEseUJBQVIsQ0FBdkI7O0FBRUEsTUFBTWEsTUFBTUMsUUFBUUQsR0FBUixDQUFZRSxRQUFaLElBQXdCLGFBQXBDOztBQUVBLE1BQU1DLEtBQU4sQ0FBWTtBQUNWQyxjQUFZQyxTQUFTLEVBQXJCLEVBQXlCO0FBQ3ZCakIsVUFBTSxrQkFBTixFQUEwQmlCLE1BQTFCOztBQUVBO0FBQ0EsUUFBSUEsT0FBT0MsWUFBWCxFQUF5QjtBQUN2QkQsYUFBT04sY0FBUCxHQUF3Qk0sT0FBT0MsWUFBL0I7QUFDQSxhQUFPRCxP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LFdBQU9pQixPQUFQLEVBQWdCNEIsTUFBaEIsRUFBMkI7QUFDNUMsWUFBSTtBQUNGO0FBQ0EsZ0JBQU15QyxNQUFNLE1BQU0sT0FBS2YsU0FBTCxDQUFlQyxRQUFmLEVBQXlCaEQsTUFBekIsRUFBaUNFLE9BQWpDLENBQWxCOztBQUVBO0FBQ0FtQyxpQkFBT0MsTUFBUCxDQUFjcEMsT0FBZCxFQUF1QjRELEdBQXZCOztBQUVBLGNBQUksT0FBSzlFLE1BQUwsQ0FBWXFCLE9BQWhCLEVBQXlCO0FBQ3ZCdEMsa0JBQU0sd0NBQU47QUFDQSxrQkFBTU8sYUFBYTRCLE9BQWIsQ0FBTjtBQUNEOztBQUVELGNBQUksQ0FBQyxPQUFLbEIsTUFBTCxDQUFZbUIsSUFBakIsRUFBdUI7QUFDckJwQyxrQkFBTSxnREFBTjtBQUNBO0FBQ0E7QUFDQSxtQkFBS2lCLE1BQUwsQ0FBWThCLFNBQVosR0FBd0IxQyxXQUFXNkMsZUFBWCxDQUEyQjtBQUNqRDhDLDZCQUFlO0FBRGtDLGFBQTNCLENBQXhCO0FBR0Q7O0FBRUQsZ0JBQU0vQixNQUFNLE1BQU0sT0FBS2hELE1BQUwsQ0FBWThCLFNBQVosQ0FBc0JFLFFBQXRCLENBQStCZCxPQUEvQixDQUFsQjtBQUNBbkMsZ0JBQU0sY0FBTjtBQUNBMEIsa0JBQVF1QyxHQUFSO0FBQ0QsU0F4QkQsQ0F3QkUsT0FBT1AsR0FBUCxFQUFZO0FBQ1pKLGlCQUFPSSxHQUFQO0FBQ0Q7QUFDRixPQTVCTTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFQO0FBNkJEO0FBbFNTOztBQXFTWnVDLE9BQU9DLE9BQVAsR0FBaUJuRixLQUFqQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VtYWlsLXRlbXBsYXRlcycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcy1leHRyYScpO1xuY29uc3QgaHRtbFRvVGV4dCA9IHJlcXVpcmUoJ2h0bWwtdG8tdGV4dCcpO1xuY29uc3QgSTE4TiA9IHJlcXVpcmUoJ0BsYWRqcy9pMThuJyk7XG5jb25zdCBhdXRvQmluZCA9IHJlcXVpcmUoJ2F1dG8tYmluZCcpO1xuY29uc3Qgbm9kZW1haWxlciA9IHJlcXVpcmUoJ25vZGVtYWlsZXInKTtcbmNvbnN0IGNvbnNvbGlkYXRlID0gcmVxdWlyZSgnY29uc29saWRhdGUnKTtcbmNvbnN0IHByZXZpZXdFbWFpbCA9IHJlcXVpcmUoJ3ByZXZpZXctZW1haWwnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG5jb25zdCBnZXRQYXRocyA9IHJlcXVpcmUoJ2dldC1wYXRocycpO1xuY29uc3QganVpY2VSZXNvdXJjZXMgPSByZXF1aXJlKCdqdWljZS1yZXNvdXJjZXMtcHJvbWlzZScpO1xuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnO1xuXG5jbGFzcyBFbWFpbCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgZGVidWcoJ2NvbmZpZyBwYXNzZWQgJU8nLCBjb25maWcpO1xuXG4gICAgLy8gMi54IGJhY2t3YXJkcyBjb21wYXRpYmxlIHN1cHBvcnRcbiAgICBpZiAoY29uZmlnLmp1aWNlT3B0aW9ucykge1xuICAgICAgY29uZmlnLmp1aWNlUmVzb3VyY2VzID0gY29uZmlnLmp1aWNlT3B0aW9ucztcbiAgICAgIGRlbGV0ZSBjb25maWcuanVpY2VPcHRpb25zO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmRpc2FibGVKdWljZSkge1xuICAgICAgY29uZmlnLmp1aWNlID0gZmFsc2U7XG4gICAgICBkZWxldGUgY29uZmlnLmRpc2FibGVKdWljZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5yZW5kZXIpIHtcbiAgICAgIGNvbmZpZy5jdXN0b21SZW5kZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlnID0gXy5tZXJnZShcbiAgICAgIHtcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAvLyBkaXJlY3Rvcnkgd2hlcmUgZW1haWwgdGVtcGxhdGVzIHJlc2lkZVxuICAgICAgICAgIHJvb3Q6IHBhdGgucmVzb2x2ZSgnZW1haWxzJyksXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBmaWxlIGV4dGVuc2lvbiBmb3IgdGVtcGxhdGVcbiAgICAgICAgICAgIGV4dGVuc2lvbjogJ3B1ZycsXG4gICAgICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgICAgaGJzOiAnaGFuZGxlYmFycycsXG4gICAgICAgICAgICAgIG5qazogJ251bmp1Y2tzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZ2luZVNvdXJjZTogY29uc29saWRhdGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGxvY2FscyB0byBwYXNzIHRvIHRlbXBsYXRlcyBmb3IgcmVuZGVyaW5nXG4gICAgICAgICAgbG9jYWxzOiB7XG4gICAgICAgICAgICAvLyBwcmV0dHkgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gYGZhbHNlYCBmb3Igc3ViamVjdC90ZXh0XG4gICAgICAgICAgICBwcmV0dHk6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIDxodHRwczovL25vZGVtYWlsZXIuY29tL21lc3NhZ2UvPlxuICAgICAgICBtZXNzYWdlOiB7fSxcbiAgICAgICAgc2VuZDogIVsnZGV2ZWxvcG1lbnQnLCAndGVzdCddLmluY2x1ZGVzKGVudiksXG4gICAgICAgIHByZXZpZXc6IGVudiA9PT0gJ2RldmVsb3BtZW50JyxcbiAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9sYWRqcy9pMThuPlxuICAgICAgICAvLyBzZXQgdG8gYW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSBhbmQgZW5hYmxlIGl0XG4gICAgICAgIGkxOG46IGZhbHNlLFxuICAgICAgICAvLyBwYXNzIGEgY3VzdG9tIHJlbmRlciBmdW5jdGlvbiBpZiBuZWNlc3NhcnlcbiAgICAgICAgcmVuZGVyOiB0aGlzLnJlbmRlci5iaW5kKHRoaXMpLFxuICAgICAgICBjdXN0b21SZW5kZXI6IGZhbHNlLFxuICAgICAgICAvLyBmb3JjZSB0ZXh0LW9ubHkgcmVuZGVyaW5nIG9mIHRlbXBsYXRlIChkaXNyZWdhcmRzIHRlbXBsYXRlIGZvbGRlcilcbiAgICAgICAgdGV4dE9ubHk6IGZhbHNlLFxuICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL3dlcms4NS9ub2RlLWh0bWwtdG8tdGV4dD5cbiAgICAgICAgaHRtbFRvVGV4dDoge1xuICAgICAgICAgIGlnbm9yZUltYWdlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHN1YmplY3RQcmVmaXg6IGZhbHNlLFxuICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvanVpY2U+XG4gICAgICAgIGp1aWNlOiB0cnVlLFxuICAgICAgICBqdWljZVJlc291cmNlczoge1xuICAgICAgICAgIHByZXNlcnZlSW1wb3J0YW50OiB0cnVlLFxuICAgICAgICAgIHdlYlJlc291cmNlczoge1xuICAgICAgICAgICAgcmVsYXRpdmVUbzogcGF0aC5yZXNvbHZlKCdidWlsZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBwYXNzIGEgdHJhbnNwb3J0IGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9yIGEgdHJhbnNwb3J0IGluc3RhbmNlXG4gICAgICAgIC8vIChlLmcuIGFuIGluc3RhbmNlIGlzIGNyZWF0ZWQgdmlhIGBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydGApXG4gICAgICAgIC8vIDxodHRwczovL25vZGVtYWlsZXIuY29tL3RyYW5zcG9ydHMvPlxuICAgICAgICB0cmFuc3BvcnQ6IHt9XG4gICAgICB9LFxuICAgICAgY29uZmlnXG4gICAgKTtcblxuICAgIC8vIG92ZXJyaWRlIGV4aXN0aW5nIG1ldGhvZFxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5jb25maWcucmVuZGVyO1xuXG4gICAgaWYgKCFfLmlzRnVuY3Rpb24odGhpcy5jb25maWcudHJhbnNwb3J0LnNlbmRNYWlsKSlcbiAgICAgIHRoaXMuY29uZmlnLnRyYW5zcG9ydCA9IG5vZGVtYWlsZXIuY3JlYXRlVHJhbnNwb3J0KHRoaXMuY29uZmlnLnRyYW5zcG9ydCk7XG5cbiAgICBkZWJ1ZygndHJhbnNmb3JtZWQgY29uZmlnICVPJywgdGhpcy5jb25maWcpO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG4gIH1cblxuICAvLyBzaG9ydGhhbmQgdXNlIG9mIGBqdWljZVJlc291cmNlc2Agd2l0aCB0aGUgY29uZmlnXG4gIC8vIChtYWlubHkgZm9yIGN1c3RvbSByZW5kZXJzIGxpa2UgZnJvbSBhIGRhdGFiYXNlKVxuICBqdWljZVJlc291cmNlcyhodG1sKSB7XG4gICAgcmV0dXJuIGp1aWNlUmVzb3VyY2VzKGh0bWwsIHRoaXMuY29uZmlnLmp1aWNlUmVzb3VyY2VzKTtcbiAgfVxuXG4gIC8vIGEgc2ltcGxlIGhlbHBlciBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFjdHVhbCBmaWxlIHBhdGggZm9yIHRoZSB0ZW1wbGF0ZVxuICBnZXRUZW1wbGF0ZVBhdGgodmlldykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXRocyA9IGF3YWl0IGdldFBhdGhzKFxuICAgICAgICAgIHRoaXMuY29uZmlnLnZpZXdzLnJvb3QsXG4gICAgICAgICAgdmlldyxcbiAgICAgICAgICB0aGlzLmNvbmZpZy52aWV3cy5vcHRpb25zLmV4dGVuc2lvblxuICAgICAgICApO1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLmNvbmZpZy52aWV3cy5yb290LCBwYXRocy5yZWwpO1xuICAgICAgICByZXNvbHZlKHsgZmlsZVBhdGgsIHBhdGhzIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGEgdGVtcGxhdGUgZXhpc3RzXG4gIC8vICh1c2VzIHNhbWUgbG9vay11cCBhcHByb2FjaCBhcyBgcmVuZGVyYCBmdW5jdGlvbilcbiAgdGVtcGxhdGVFeGlzdHModmlldykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyByZXNvbHZlID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZmlsZVBhdGggfSA9IGF3YWl0IHRoaXMuZ2V0VGVtcGxhdGVQYXRoKHZpZXcpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoIXN0YXRzLmlzRmlsZSgpKSB0aHJvdyBuZXcgRXJyb3IoYCR7ZmlsZVBhdGh9IHdhcyBub3QgYSBmaWxlYCk7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGVidWcoJ3RlbXBsYXRlRXhpc3RzJywgZXJyKTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBwcm9taXNlIHZlcnNpb24gb2YgY29uc29saWRhdGUncyByZW5kZXJcbiAgLy8gaW5zcGlyZWQgYnkga29hLXZpZXdzIGFuZCByZS11c2VzIHRoZSBzYW1lIGNvbmZpZ1xuICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL3F1ZWNrZXp6L2tvYS12aWV3cz5cbiAgcmVuZGVyKHZpZXcsIGxvY2FscyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgbWFwLCBlbmdpbmVTb3VyY2UgfSA9IHRoaXMuY29uZmlnLnZpZXdzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgZmlsZVBhdGgsIHBhdGhzIH0gPSBhd2FpdCB0aGlzLmdldFRlbXBsYXRlUGF0aCh2aWV3KTtcbiAgICAgICAgaWYgKHBhdGhzLmV4dCA9PT0gJ2h0bWwnICYmICFtYXApIHtcbiAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZW5naW5lTmFtZSA9IG1hcCAmJiBtYXBbcGF0aHMuZXh0XSA/IG1hcFtwYXRocy5leHRdIDogcGF0aHMuZXh0O1xuICAgICAgICAgIGNvbnN0IHJlbmRlckZuID0gZW5naW5lU291cmNlW2VuZ2luZU5hbWVdO1xuICAgICAgICAgIGlmICghZW5naW5lTmFtZSB8fCAhcmVuZGVyRm4pXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEVuZ2luZSBub3QgZm91bmQgZm9yIHRoZSBcIi4ke3BhdGhzLmV4dH1cIiBmaWxlIGV4dGVuc2lvbmBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHRoaXMuY29uZmlnLmkxOG4pKSB7XG4gICAgICAgICAgICBjb25zdCBpMThuID0gbmV3IEkxOE4oXG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnLmkxOG4sIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogbG9jYWxzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBzdXBwb3J0IGBsb2NhbHMudXNlci5sYXN0X2xvY2FsZWBcbiAgICAgICAgICAgIC8vIChlLmcuIGZvciA8aHR0cHM6Ly9sYWQuanMub3JnPilcbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KGxvY2Fscy51c2VyKSAmJiBfLmlzU3RyaW5nKGxvY2Fscy51c2VyLmxhc3RfbG9jYWxlKSlcbiAgICAgICAgICAgICAgbG9jYWxzLmxvY2FsZSA9IGxvY2Fscy51c2VyLmxhc3RfbG9jYWxlO1xuXG4gICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhsb2NhbHMubG9jYWxlKSkgaTE4bi5zZXRMb2NhbGUobG9jYWxzLmxvY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogY29udmVydCB0aGlzIHRvIGEgcHJvbWlzZSBiYXNlZCB2ZXJzaW9uXG4gICAgICAgICAgcmVuZGVyRm4oZmlsZVBhdGgsIGxvY2FscywgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0gdGhlIGh0bWwgd2l0aCBqdWljZSB1c2luZyByZW1vdGUgcGF0aHNcbiAgICAgICAgICAgIC8vIGdvb2dsZSBub3cgc3VwcG9ydHMgbWVkaWEgcXVlcmllc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vZ21haWwvZGVzaWduL3JlZmVyZW5jZS9zdXBwb3J0ZWRfY3NzXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmp1aWNlKSByZXR1cm4gcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgdGhpcy5qdWljZVJlc291cmNlcyhyZXMpXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZW5kZXJBbGwodGVtcGxhdGUsIGxvY2FscyA9IHt9LCBtZXNzYWdlID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHN1YmplY3RUZW1wbGF0ZUV4aXN0cyA9IHRoaXMuY29uZmlnLmN1c3RvbVJlbmRlcjtcbiAgICAgICAgbGV0IGh0bWxUZW1wbGF0ZUV4aXN0cyA9IHRoaXMuY29uZmlnLmN1c3RvbVJlbmRlcjtcbiAgICAgICAgbGV0IHRleHRUZW1wbGF0ZUV4aXN0cyA9IHRoaXMuY29uZmlnLmN1c3RvbVJlbmRlcjtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlRXhpc3RzKGAke3RlbXBsYXRlfS9zdWJqZWN0YCksXG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUV4aXN0cyhgJHt0ZW1wbGF0ZX0vaHRtbGApLFxuICAgICAgICAgIHRoaXMudGVtcGxhdGVFeGlzdHMoYCR7dGVtcGxhdGV9L3RleHRgKVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmICh0ZW1wbGF0ZSAmJiAhdGhpcy5jb25maWcuY3VzdG9tUmVuZGVyKVxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHN1YmplY3RUZW1wbGF0ZUV4aXN0cyxcbiAgICAgICAgICAgIGh0bWxUZW1wbGF0ZUV4aXN0cyxcbiAgICAgICAgICAgIHRleHRUZW1wbGF0ZUV4aXN0c1xuICAgICAgICAgIF0gPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgaWYgKCFtZXNzYWdlLnN1YmplY3QgJiYgc3ViamVjdFRlbXBsYXRlRXhpc3RzKSB7XG4gICAgICAgICAgbWVzc2FnZS5zdWJqZWN0ID0gYXdhaXQgdGhpcy5yZW5kZXIoXG4gICAgICAgICAgICBgJHt0ZW1wbGF0ZX0vc3ViamVjdGAsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBsb2NhbHMsIHsgcHJldHR5OiBmYWxzZSB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgbWVzc2FnZS5zdWJqZWN0ID0gbWVzc2FnZS5zdWJqZWN0LnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXNzYWdlLnN1YmplY3QgJiYgdGhpcy5jb25maWcuc3ViamVjdFByZWZpeClcbiAgICAgICAgICBtZXNzYWdlLnN1YmplY3QgPSB0aGlzLmNvbmZpZy5zdWJqZWN0UHJlZml4ICsgbWVzc2FnZS5zdWJqZWN0O1xuXG4gICAgICAgIGlmICghbWVzc2FnZS5odG1sICYmIGh0bWxUZW1wbGF0ZUV4aXN0cylcbiAgICAgICAgICBtZXNzYWdlLmh0bWwgPSBhd2FpdCB0aGlzLnJlbmRlcihgJHt0ZW1wbGF0ZX0vaHRtbGAsIGxvY2Fscyk7XG5cbiAgICAgICAgaWYgKCFtZXNzYWdlLnRleHQgJiYgdGV4dFRlbXBsYXRlRXhpc3RzKVxuICAgICAgICAgIG1lc3NhZ2UudGV4dCA9IGF3YWl0IHRoaXMucmVuZGVyKFxuICAgICAgICAgICAgYCR7dGVtcGxhdGV9L3RleHRgLFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbG9jYWxzLCB7IHByZXR0eTogZmFsc2UgfSlcbiAgICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5odG1sVG9UZXh0ICYmIG1lc3NhZ2UuaHRtbCAmJiAhbWVzc2FnZS50ZXh0KVxuICAgICAgICAgIC8vIHdlJ2QgdXNlIG5vZGVtYWlsZXItaHRtbC10by10ZXh0IHBsdWdpblxuICAgICAgICAgIC8vIGJ1dCB3ZSByZWFsbHkgZG9uJ3QgbmVlZCB0byBzdXBwb3J0IGNpZFxuICAgICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vYW5kcmlzOS9ub2RlbWFpbGVyLWh0bWwtdG8tdGV4dD5cbiAgICAgICAgICBtZXNzYWdlLnRleHQgPSBodG1sVG9UZXh0LmZyb21TdHJpbmcoXG4gICAgICAgICAgICBtZXNzYWdlLmh0bWwsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5odG1sVG9UZXh0XG4gICAgICAgICAgKTtcblxuICAgICAgICAvLyBpZiB3ZSBvbmx5IHdhbnQgYSB0ZXh0LWJhc2VkIHZlcnNpb24gb2YgdGhlIGVtYWlsXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy50ZXh0T25seSkgZGVsZXRlIG1lc3NhZ2UuaHRtbDtcblxuICAgICAgICByZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2VuZChvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgdGVtcGxhdGU6ICcnLFxuICAgICAgICBtZXNzYWdlOiB7fSxcbiAgICAgICAgbG9jYWxzOiB7fVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgbGV0IHsgdGVtcGxhdGUsIG1lc3NhZ2UsIGxvY2FscyB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGF0dGFjaG1lbnRzID1cbiAgICAgIG1lc3NhZ2UuYXR0YWNobWVudHMgfHwgdGhpcy5jb25maWcubWVzc2FnZS5hdHRhY2htZW50cyB8fCBbXTtcblxuICAgIG1lc3NhZ2UgPSBfLmRlZmF1bHRzRGVlcChcbiAgICAgIHt9LFxuICAgICAgXy5vbWl0KHRoaXMuY29uZmlnLm1lc3NhZ2UsICdhdHRhY2htZW50cycpLFxuICAgICAgXy5vbWl0KG1lc3NhZ2UsICdhdHRhY2htZW50cycpXG4gICAgKTtcbiAgICBsb2NhbHMgPSBfLmRlZmF1bHRzRGVlcCh7fSwgdGhpcy5jb25maWcudmlld3MubG9jYWxzLCBsb2NhbHMpO1xuXG4gICAgaWYgKGF0dGFjaG1lbnRzKSBtZXNzYWdlLmF0dGFjaG1lbnRzID0gYXR0YWNobWVudHM7XG5cbiAgICBkZWJ1ZygndGVtcGxhdGUgJXMnLCB0ZW1wbGF0ZSk7XG4gICAgZGVidWcoJ21lc3NhZ2UgJU8nLCBtZXNzYWdlKTtcbiAgICBkZWJ1ZygnbG9jYWxzIChrZXlzIG9ubHkpOiAlTycsIE9iamVjdC5rZXlzKGxvY2FscykpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGdldCBhbGwgYXZhaWxhYmxlIHRlbXBsYXRlc1xuICAgICAgICBjb25zdCBvYmogPSBhd2FpdCB0aGlzLnJlbmRlckFsbCh0ZW1wbGF0ZSwgbG9jYWxzLCBtZXNzYWdlKTtcblxuICAgICAgICAvLyBhc3NpZ24gdGhlIG9iamVjdCB2YXJpYWJsZXMgb3ZlciB0byB0aGUgbWVzc2FnZVxuICAgICAgICBPYmplY3QuYXNzaWduKG1lc3NhZ2UsIG9iaik7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXZpZXcpIHtcbiAgICAgICAgICBkZWJ1ZygndXNpbmcgYHByZXZpZXctZW1haWxgIHRvIHByZXZpZXcgZW1haWwnKTtcbiAgICAgICAgICBhd2FpdCBwcmV2aWV3RW1haWwobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnNlbmQpIHtcbiAgICAgICAgICBkZWJ1Zygnc2VuZCBkaXNhYmxlZCBzbyB3ZSBhcmUgZW5zdXJpbmcgSlNPTlRyYW5zcG9ydCcpO1xuICAgICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vbm9kZW1haWxlci9ub2RlbWFpbGVyL2lzc3Vlcy83OTg+XG4gICAgICAgICAgLy8gaWYgKHRoaXMuY29uZmlnLnRyYW5zcG9ydC5uYW1lICE9PSAnSlNPTlRyYW5zcG9ydCcpXG4gICAgICAgICAgdGhpcy5jb25maWcudHJhbnNwb3J0ID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQoe1xuICAgICAgICAgICAganNvblRyYW5zcG9ydDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jb25maWcudHJhbnNwb3J0LnNlbmRNYWlsKG1lc3NhZ2UpO1xuICAgICAgICBkZWJ1ZygnbWVzc2FnZSBzZW50Jyk7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVtYWlsO1xuIl19